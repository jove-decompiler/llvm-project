# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O2 -mtriple=tricore -global-isel -run-pass=greedy -verify-machineinstrs %s -o - | FileCheck %s

# A reserved register is always considered live. With the introduction of PSW_C,
# a subregister of PSW, there was a problem where PSW was sometimes not
# considered live anymore. This happened because PSW_C was not marked as
# reserved. Basically, because a subregister of PSW was not reserved, the full
# superregister (PSW) could also not be considered 100% reserved anymore,
# causing crashes in the register allocator.
#
# This test checks that we have properly marked PSW_C as reserved and that the
# register allocator does not crash anymore.
# If one wants to check for the correctness of this test in the future, simply
# replace markSuperRegs(Reserved, TriCore::PSW_C) with
# markSuperRegs(Reserved, TriCore::PSW) in TriCoreRegisterInfo.cpp

--- |
  ; ModuleID = 't1.ll'
  source_filename = "t1.c"
  target datalayout = "e-m:e-i64:32-p:32:32-f64:32-n32-a:0:32-S64"
  target triple = "tricore"

  @a = common dso_local local_unnamed_addr global double 0.000000e+00, align 4
  @c = common dso_local local_unnamed_addr global i32 0, align 4
  @b = common dso_local local_unnamed_addr global i64 0, align 4

  ; Function Attrs: nofree norecurse nounwind
  define dso_local i32 @test_psw_marked_reserved() local_unnamed_addr #0 {
  entry:
    %0 = load double, double* @a, align 4, !tbaa !2
    %conv = fptosi double %0 to i32
    store i32 %conv, i32* @c, align 4, !tbaa !6
    %1 = load i64, i64* @b, align 4, !tbaa !8
    %sub = sub nsw i64 0, %1
    store i64 %sub, i64* @b, align 4, !tbaa !8
    ret i32 undef
  }

  attributes #0 = { nofree norecurse nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="tc2xx" "target-features"="+tc161" "unsafe-fp-math"="false" "use-soft-float"="false" }

  !llvm.module.flags = !{!0}
  !llvm.ident = !{!1}

  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{!"clang version 11.0.0 (ssh://git@bitbucket-server.software.htc:7999/toolchain/llvm-project.git 03344c6a3b98b4cb2a95f9f03c89035a89c05fd6)"}
  !2 = !{!3, !3, i64 0}
  !3 = !{!"double", !4, i64 0}
  !4 = !{!"omnipotent char", !5, i64 0}
  !5 = !{!"Simple C/C++ TBAA"}
  !6 = !{!7, !7, i64 0}
  !7 = !{!"int", !4, i64 0}
  !8 = !{!9, !9, i64 0}
  !9 = !{!"long long", !4, i64 0}

...
---
name:            test_psw_marked_reserved
exposesReturnsTwice: false
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
body:             |
  bb.0.entry:
    ; CHECK-LABEL: name: test_psw_marked_reserved
    ; CHECK: [[MOVHA_ac:%[0-9]+]]:addrregs = MOVHA_ac target-flags(tricore-hi) @a
    ; CHECK: [[LEA_aac:%[0-9]+]]:addrregs = LEA_aac [[MOVHA_ac]], target-flags(tricore-lo) @a
    ; CHECK: [[MOVHA_ac1:%[0-9]+]]:addrregs = MOVHA_ac target-flags(tricore-hi) @c
    ; CHECK: [[LEA_aac1:%[0-9]+]]:addrregs = LEA_aac [[MOVHA_ac1]], target-flags(tricore-lo) @c
    ; CHECK: [[MOVHA_ac2:%[0-9]+]]:addrregs = MOVHA_ac target-flags(tricore-hi) @b
    ; CHECK: [[LEA_aac2:%[0-9]+]]:addrregs = LEA_aac [[MOVHA_ac2]], target-flags(tricore-lo) @b
    ; CHECK: [[MOVImmExtDataReg:%[0-9]+]]:extdataregs = MOVImmExtDataReg 0
    ; CHECK: [[LDD_eac:%[0-9]+]]:extdataregs = LDD_eac [[LEA_aac]], 0 :: (dereferenceable load 8 from @a, align 4, !tbaa !2)
    ; CHECK: ADJCALLSTACKDOWN 0, 0, implicit-def $a10, implicit $a10
    ; CHECK: $e4 = COPY [[LDD_eac]]
    ; CHECK: CALL &__fixdfsi, csr_tricore_uppercontext, implicit-def $a11, implicit $psw, implicit $e4, implicit-def $d2
    ; CHECK: [[COPY:%[0-9]+]]:dataregs = COPY $d2
    ; CHECK: ADJCALLSTACKUP 0, 0, implicit-def $a10, implicit $a10
    ; CHECK: STW_alcd [[LEA_aac1]], 0, [[COPY]] :: (store 4 into @c, !tbaa !6)
    ; CHECK: [[LDD_eac1:%[0-9]+]]:extdataregs = LDD_eac [[LEA_aac2]], 0 :: (dereferenceable load 8 from @b, align 4, !tbaa !8)
    ; CHECK: undef %10.dsub0:extdataregs = SUBX_ddd [[MOVImmExtDataReg]].dsub0, [[LDD_eac1]].dsub0, implicit-def $psw
    ; CHECK: %10.dsub1:extdataregs = SUBC_ddd [[MOVImmExtDataReg]].dsub1, [[LDD_eac1]].dsub1, implicit-def $psw, implicit $psw
    ; CHECK: STD_ace [[LEA_aac2]], 0, %10 :: (store 8 into @b, align 4, !tbaa !8)
    ; CHECK: RET implicit $a11, implicit undef $d2
    %19:addrregs = MOVHA_ac target-flags(tricore-hi) @a
    %1:addrregs = LEA_aac %19, target-flags(tricore-lo) @a
    %18:addrregs = MOVHA_ac target-flags(tricore-hi) @c
    %3:addrregs = LEA_aac %18, target-flags(tricore-lo) @c
    %17:addrregs = MOVHA_ac target-flags(tricore-hi) @b
    %5:addrregs = LEA_aac %17, target-flags(tricore-lo) @b
    %6:extdataregs = MOVImmExtDataReg 0
    %0:extdataregs = LDD_eac %1, 0 :: (dereferenceable load 8 from @a, align 4, !tbaa !2)
    ADJCALLSTACKDOWN 0, 0, implicit-def $a10, implicit $a10
    $e4 = COPY %0
    CALL &__fixdfsi, csr_tricore_uppercontext, implicit-def $a11, implicit $psw, implicit killed $e4, implicit-def $d2
    %2:dataregs = COPY killed $d2
    ADJCALLSTACKUP 0, 0, implicit-def $a10, implicit $a10
    STW_alcd %3, 0, %2 :: (store 4 into @c, !tbaa !6)
    %4:extdataregs = LDD_eac %5, 0 :: (dereferenceable load 8 from @b, align 4, !tbaa !8)
    undef %7.dsub0:extdataregs = SUBX_ddd %6.dsub0, %4.dsub0, implicit-def $psw
    %7.dsub1:extdataregs = SUBC_ddd %6.dsub1, %4.dsub1, implicit-def $psw, implicit $psw
    STD_ace %5, 0, %7 :: (store 8 into @b, align 4, !tbaa !8)
    RET implicit $a11, implicit undef $d2

...
