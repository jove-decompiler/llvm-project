; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -O0 -mtriple=tricore -global-isel -stop-after=irtranslator --verify-machineinstrs %s -o - | FileCheck %s

@_ZTIi = external global i8*

declare i32 @foo(i32)
declare i32 @__gxx_personality_v0(...)
declare i32 @llvm.eh.typeid.for(i8*)

define i32 @bar() personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  ; CHECK-LABEL: name: bar
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; CHECK:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   ADJCALLSTACKDOWN 0, 0, implicit-def $a10, implicit $a10
  ; CHECK:   $d4 = COPY [[C]](s32)
  ; CHECK:   CALL @foo, csr_tricore_uppercontext, implicit-def $a11, implicit $psw, implicit $d4, implicit-def $d2
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $d2
  ; CHECK:   ADJCALLSTACKUP 0, 0, implicit-def $a10, implicit $a10
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   G_BR %bb.3
  ; CHECK: bb.2.broken (landing-pad):
  ; CHECK:   liveins: $a4, $d4
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK:   [[COPY1:%[0-9]+]]:_(p0) = COPY $a4
  ; CHECK:   [[COPY2:%[0-9]+]]:_(p0) = COPY $d4
  ; CHECK:   [[PTRTOINT:%[0-9]+]]:_(s32) = G_PTRTOINT [[COPY2]](p0)
  ; CHECK:   $d2 = COPY [[PTRTOINT]](s32)
  ; CHECK:   RET implicit $a11, implicit $d2
  ; CHECK: bb.3.continue:
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK:   $d2 = COPY [[C1]](s32)
  ; CHECK:   RET implicit $a11, implicit $d2
  %res32 = invoke i32 @foo(i32 42) to label %continue unwind label %broken


broken:
  %ptr.sel = landingpad { i8*, i32 } catch i8* bitcast(i8** @_ZTIi to i8*)
  %sel = extractvalue { i8*, i32 } %ptr.sel, 1
  ret i32 %sel

continue:
  %sel.int = tail call i32 @llvm.eh.typeid.for(i8* bitcast(i8** @_ZTIi to i8*))
  ret i32 %sel.int
}

define void @test_invoke_indirect(void()* %callee) personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  ; CHECK-LABEL: name: test_invoke_indirect
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; CHECK:   liveins: $a4
  ; CHECK:   [[COPY:%[0-9]+]]:addrregs(p0) = COPY $a4
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   ADJCALLSTACKDOWN 0, 0, implicit-def $a10, implicit $a10
  ; CHECK:   CALLI [[COPY]](p0), csr_tricore_uppercontext, implicit-def $a11, implicit $psw
  ; CHECK:   ADJCALLSTACKUP 0, 0, implicit-def $a10, implicit $a10
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   G_BR %bb.3
  ; CHECK: bb.2.broken (landing-pad):
  ; CHECK:   liveins: $a4, $d4
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK:   [[COPY1:%[0-9]+]]:_(p0) = COPY $a4
  ; CHECK:   [[COPY2:%[0-9]+]]:_(p0) = COPY $d4
  ; CHECK:   [[PTRTOINT:%[0-9]+]]:_(s32) = G_PTRTOINT [[COPY2]](p0)
  ; CHECK:   RET implicit $a11
  ; CHECK: bb.3.continue:
  ; CHECK:   RET implicit $a11
  invoke void %callee() to label %continue unwind label %broken

broken:
  landingpad { i8*, i32 } catch i8* bitcast(i8** @_ZTIi to i8*)
  ret void

continue:
  ret void
}

declare void @printf(i8*, ...)
define void @test_invoke_varargs() personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
  ; CHECK-LABEL: name: test_invoke_varargs
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK:   successors: %bb.3(0x40000000), %bb.2(0x40000000)
  ; CHECK:   [[C:%[0-9]+]]:_(p0) = G_CONSTANT i32 0
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 42
  ; CHECK:   [[C2:%[0-9]+]]:_(s32) = G_FCONSTANT float 1.000000e+00
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   ADJCALLSTACKDOWN 8, 0, implicit-def $a10, implicit $a10
  ; CHECK:   $a4 = COPY [[C]](p0)
  ; CHECK:   [[COPY:%[0-9]+]]:_(p0) = COPY $a10
  ; CHECK:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY]], [[C3]](s32)
  ; CHECK:   G_STORE [[C1]](s32), [[PTR_ADD]](p0) :: (store 4 into stack, align 8)
  ; CHECK:   [[COPY1:%[0-9]+]]:_(p0) = COPY $a10
  ; CHECK:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 4
  ; CHECK:   [[PTR_ADD1:%[0-9]+]]:_(p0) = G_PTR_ADD [[COPY1]], [[C4]](s32)
  ; CHECK:   G_STORE [[C2]](s32), [[PTR_ADD1]](p0) :: (store 4 into stack + 4)
  ; CHECK:   CALL @printf, csr_tricore_uppercontext, implicit-def $a11, implicit $psw, implicit $a4
  ; CHECK:   ADJCALLSTACKUP 8, 0, implicit-def $a10, implicit $a10
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   G_BR %bb.3
  ; CHECK: bb.2.broken (landing-pad):
  ; CHECK:   liveins: $a4, $d4
  ; CHECK:   EH_LABEL <mcsymbol >
  ; CHECK:   [[DEF:%[0-9]+]]:_(s64) = G_IMPLICIT_DEF
  ; CHECK:   [[COPY2:%[0-9]+]]:_(p0) = COPY $a4
  ; CHECK:   [[COPY3:%[0-9]+]]:_(p0) = COPY $d4
  ; CHECK:   [[PTRTOINT:%[0-9]+]]:_(s32) = G_PTRTOINT [[COPY3]](p0)
  ; CHECK:   RET implicit $a11
  ; CHECK: bb.3.continue:
  ; CHECK:   RET implicit $a11
  invoke void(i8*, ...) @printf(i8* null, i32 42, float 1.0) to label %continue unwind label %broken

broken:
  landingpad { i8*, i32 } catch i8* bitcast(i8** @_ZTIi to i8*)
  ret void

continue:
  ret void
}
