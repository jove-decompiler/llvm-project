# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=tricore -global-isel -run-pass=legalizer -verify-machineinstrs %s -o - | FileCheck %s

--- |
  source_filename = "tstack.i"
  target datalayout = "e-m:e-i64:32-p:32:32-f64:32-n32-a:0:32-S64"
  target triple = "tricore"

  @a = dso_local local_unnamed_addr global i32 0, align 4
  @b = dso_local local_unnamed_addr global [0 x double] zeroinitializer, align 4
  @c = dso_local local_unnamed_addr global i32 0, align 4

  ; Function Attrs: nofree norecurse nounwind
  define dso_local double @supertest_tstack(i32 %e) local_unnamed_addr {
  entry:
    %0 = load i32, i32* @a, align 4
    %tobool = icmp eq i32 %0, 0
    br i1 %tobool, label %if.end, label %if.then

  if.then:                                          ; preds = %entry
    %conv = sitofp i32 %e to double
    %1 = call { i32, i1 } @llvm.uadd.with.overflow.i32(i32 %0, i32 1)
    %math = extractvalue { i32, i1 } %1, 0
    %ov = extractvalue { i32, i1 } %1, 1
    store i32 %math, i32* @a, align 4
    %arrayidx = getelementptr inbounds [0 x double], [0 x double]* @b, i32 0, i32 %0
    store double %conv, double* %arrayidx, align 4
    br label %if.end

  if.end:                                           ; preds = %if.then, %entry
    %2 = phi i1 [ true, %entry ], [ %ov, %if.then ]
    %3 = load i32, i32* @c, align 4
    %tobool2 = icmp ne i32 %3, 0
    %4 = and i1 %2, %tobool2
    %conv3 = uitofp i1 %4 to double
    ret double %conv3
  }

  declare { i32, i1 } @llvm.uadd.with.overflow.i32(i32, i32)

...
---
name:            supertest_tstack
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: supertest_tstack
  ; CHECK: bb.0.entry:
  ; CHECK:   successors: %bb.2(0x40000000), %bb.1(0x40000000)
  ; CHECK:   liveins: $d4
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $d4
  ; CHECK:   [[GV:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @a
  ; CHECK:   [[C:%[0-9]+]]:_(s32) = G_CONSTANT i32 0
  ; CHECK:   [[C1:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK:   [[GV1:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @b
  ; CHECK:   [[GV2:%[0-9]+]]:_(p0) = G_GLOBAL_VALUE @c
  ; CHECK:   [[C2:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK:   [[LOAD:%[0-9]+]]:_(s32) = G_LOAD [[GV]](p0) :: (dereferenceable load 4 from @a)
  ; CHECK:   [[ICMP:%[0-9]+]]:_(s32) = G_ICMP intpred(eq), [[LOAD]](s32), [[C]]
  ; CHECK:   [[TRUNC:%[0-9]+]]:_(s1) = G_TRUNC [[ICMP]](s32)
  ; CHECK:   [[COPY1:%[0-9]+]]:_(s32) = COPY [[C2]](s32)
  ; CHECK:   G_BRCOND [[TRUNC]](s1), %bb.2
  ; CHECK: bb.1.if.then:
  ; CHECK:   successors: %bb.2(0x80000000)
  ; CHECK:   [[SITOFP:%[0-9]+]]:_(s64) = G_SITOFP [[COPY]](s32)
  ; CHECK:   [[UADDO:%[0-9]+]]:_(s32), [[UADDO1:%[0-9]+]]:_(s1) = G_UADDO [[LOAD]], [[C1]]
  ; CHECK:   G_STORE [[UADDO]](s32), [[GV]](p0) :: (store 4 into @a)
  ; CHECK:   [[C3:%[0-9]+]]:_(s32) = G_CONSTANT i32 3
  ; CHECK:   [[SHL:%[0-9]+]]:_(s32) = G_SHL [[LOAD]], [[C3]](s32)
  ; CHECK:   [[PTR_ADD:%[0-9]+]]:_(p0) = G_PTR_ADD [[GV1]], [[SHL]](s32)
  ; CHECK:   G_STORE [[SITOFP]](s64), [[PTR_ADD]](p0) :: (store 8 into %ir.arrayidx, align 4)
  ; CHECK:   [[ANYEXT:%[0-9]+]]:_(s32) = G_ANYEXT [[UADDO1]](s1)
  ; CHECK: bb.2.if.end:
  ; CHECK:   [[PHI:%[0-9]+]]:_(s32) = G_PHI [[COPY1]](s32), %bb.0, [[ANYEXT]](s32), %bb.1
  ; CHECK:   [[LOAD1:%[0-9]+]]:_(s32) = G_LOAD [[GV2]](p0) :: (dereferenceable load 4 from @c)
  ; CHECK:   [[ICMP1:%[0-9]+]]:_(s32) = G_ICMP intpred(ne), [[LOAD1]](s32), [[C]]
  ; CHECK:   [[COPY2:%[0-9]+]]:_(s32) = COPY [[PHI]](s32)
  ; CHECK:   [[COPY3:%[0-9]+]]:_(s32) = COPY [[ICMP1]](s32)
  ; CHECK:   [[AND:%[0-9]+]]:_(s32) = G_AND [[COPY2]], [[COPY3]]
  ; CHECK:   [[C4:%[0-9]+]]:_(s32) = G_CONSTANT i32 1
  ; CHECK:   [[COPY4:%[0-9]+]]:_(s32) = COPY [[AND]](s32)
  ; CHECK:   [[AND1:%[0-9]+]]:_(s32) = G_AND [[COPY4]], [[C4]]
  ; CHECK:   [[UITOFP:%[0-9]+]]:_(s64) = G_UITOFP [[AND1]](s32)
  ; CHECK:   $e2 = COPY [[UITOFP]](s64)
  ; CHECK:   RET implicit $a11, implicit $e2
  bb.1.entry:
    successors: %bb.3(0x40000000), %bb.2(0x40000000)
    liveins: $d4

    %0:_(s32) = COPY $d4
    %2:_(p0) = G_GLOBAL_VALUE @a
    %3:_(s32) = G_CONSTANT i32 0
    %8:_(s32) = G_CONSTANT i32 1
    %9:_(p0) = G_GLOBAL_VALUE @b
    %16:_(p0) = G_GLOBAL_VALUE @c
    %20:_(s1) = G_CONSTANT i1 true
    %1:_(s32) = G_LOAD %2(p0) :: (dereferenceable load 4 from @a)
    %4:_(s1) = G_ICMP intpred(eq), %1(s32), %3
    G_BRCOND %4(s1), %bb.3

  bb.2.if.then:
    successors: %bb.3(0x80000000)

    %5:_(s64) = G_SITOFP %0(s32)
    %6:_(s32), %7:_(s1) = G_UADDO %1, %8
    G_STORE %6(s32), %2(p0) :: (store 4 into @a)
    %21:_(s32) = G_CONSTANT i32 3
    %11:_(s32) = G_SHL %1, %21(s32)
    %12:_(p0) = G_PTR_ADD %9, %11(s32)
    G_STORE %5(s64), %12(p0) :: (store 8 into %ir.arrayidx, align 4)

  bb.3.if.end:
    %14:_(s1) = G_PHI %20(s1), %bb.1, %7(s1), %bb.2
    %15:_(s32) = G_LOAD %16(p0) :: (dereferenceable load 4 from @c)
    %17:_(s1) = G_ICMP intpred(ne), %15(s32), %3
    %18:_(s1) = G_AND %14, %17
    %19:_(s64) = G_UITOFP %18(s1)
    $e2 = COPY %19(s64)
    RET implicit $a11, implicit $e2

...
