; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; RUN: llc -mtriple=tricore -O0 -global-isel -stop-after=irtranslator -verify-machineinstrs -o - %s | FileCheck %s

!0 = !{i32 70}

define void @asm_simple_register_clobber() {
  ; CHECK-LABEL: name: asm_simple_register_clobber
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK:   INLINEASM &"mov %d2, 7", 1 /* sideeffect attdialect */, 12 /* clobber */, implicit-def early-clobber $d2, !0
  ; CHECK:   RET implicit $a11
  call void asm sideeffect "mov %d2, 7", "~{d2}"(), !srcloc !0
  ret void
}

define i32 @test_specific_register_output() nounwind ssp {
  ; CHECK-LABEL: name: test_specific_register_output
  ; CHECK: bb.1.entry:
  ; CHECK:   INLINEASM &"mov $0, 7", 0 /* attdialect */, 10 /* regdef */, implicit-def $d2
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY $d2
  ; CHECK:   $d2 = COPY [[COPY]](s32)
  ; CHECK:   RET implicit $a11, implicit $d2
entry:
  %0 = tail call i32 asm "mov $0, 7", "={d2}"() nounwind
  ret i32 %0
}

define i32 @test_single_register_output() nounwind ssp {
  ; CHECK-LABEL: name: test_single_register_output
  ; CHECK: bb.1.entry:
  ; CHECK:   INLINEASM &"mov $0, 7", 0 /* attdialect */, 196618 /* regdef:DataRegs */, def %0
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY %0
  ; CHECK:   $d2 = COPY [[COPY]](s32)
  ; CHECK:   RET implicit $a11, implicit $d2
entry:
  %0 = tail call i32 asm "mov $0, 7", "=d"() nounwind
  ret i32 %0
}

define i64 @test_single_register_output_s64() nounwind ssp {
  ; CHECK-LABEL: name: test_single_register_output_s64
  ; CHECK: bb.1.entry:
  ; CHECK:   INLINEASM &"mov $0, 7", 0 /* attdialect */, 524298 /* regdef:ExtDataRegs */, def %0
  ; CHECK:   [[COPY:%[0-9]+]]:_(s64) = COPY %0
  ; CHECK:   $e2 = COPY [[COPY]](s64)
  ; CHECK:   RET implicit $a11, implicit $e2
entry:
  %0 = tail call i64 asm "mov $0, 7", "=d"() nounwind
  ret i64 %0
}

; Check support for returning several floats
define double @test_multiple_register_outputs_mixed() #0 {
  ; CHECK-LABEL: name: test_multiple_register_outputs_mixed
  ; CHECK: bb.1 (%ir-block.0):
  ; CHECK:   INLINEASM &"mov $0, 0; mov $1, 0", 0 /* attdialect */, 196618 /* regdef:DataRegs */, def %0, 524298 /* regdef:ExtDataRegs */, def %1
  ; CHECK:   [[COPY:%[0-9]+]]:_(s32) = COPY %0
  ; CHECK:   [[COPY1:%[0-9]+]]:_(s64) = COPY %1
  ; CHECK:   $e2 = COPY [[COPY1]](s64)
  ; CHECK:   RET implicit $a11, implicit $e2
  %1 = call { float, double } asm "mov $0, 0; mov $1, 0", "=d,=d"()
  %asmresult = extractvalue { float, double } %1, 1
  ret double %asmresult
}
