//===- TriCoreGenRegisterBankInfo.def ----------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file defines all the static objects used by TriCoreRegisterBankInfo.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

namespace llvm {
RegisterBankInfo::PartialMapping TriCoreGenRegisterBankInfo::PartMappings[]{
    /* StartIdx, Length, RegBank */
    // 0: DataReg 32-bit value.
    {0, 32, TriCore::DataRegBank},
    // 1: ExtDataReg 64-bit value.
    {0, 64, TriCore::DataRegBank},
    // 2: AddrReg 32-bit value.
    {0, 32, TriCore::AddrRegBank},
    // 3: ExtAddrReg 64-bit value.
    {0, 64, TriCore::AddrRegBank},
    // 4: CarryReg 1-bit carry value
    {0, 1, TriCore::StatusRegBank},
};

// ValueMappings.
RegisterBankInfo::ValueMapping TriCoreGenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 3-operand instructions (all binary operations should end up with one of
    // those mappings)
    // 1: DataReg 32-bit value. <-- This must match First3OpsIdx.
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_DataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_DataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_DataReg - PMI_Min], 1},
    // 4: ExtDataReg 64-bit value.
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtDataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtDataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtDataReg - PMI_Min], 1},
    // 7: AddrReg 32-bit value.
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_AddrReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_AddrReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_AddrReg - PMI_Min], 1},
    // 10: ExtAddrReg 64-bit value. <-- This must match Last3OpsIdx.
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtAddrReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtAddrReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtAddrReg - PMI_Min], 1},
    // Truncations
    // 13: ExtDataReg 64-bit to DataReg 32-bit. <-- This must match
    // TruncDataRegBankIdx.
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_DataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtDataReg - PMI_Min], 1},
    // 15: ExtAddrReg 64-bit to AddrReg 32-bit. <-- This must match
    // TruncAddrRegBankIdx.
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_AddrReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_ExtAddrReg - PMI_Min], 1},
    // Carry-bit arithmetic
    // 17: Add/sub /w carry. <-- This must match CarryBitIdx.
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_DataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_CarryReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_DataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_DataReg - PMI_Min], 1},
    {&TriCoreGenRegisterBankInfo::PartMappings[PMI_CarryReg - PMI_Min], 1},
    // TODO: Add mappings for cross register bank copies.
    //  Create FirstCrossRegCpyIdx and LastCrossRegCpyIdx.
    //  Create DistanceBetweenCrossRegCpy = <num operands>.
};

bool TriCoreGenRegisterBankInfo::checkPartialMap(unsigned Idx,
                                                 unsigned ValStartIdx,
                                                 unsigned ValLength,
                                                 const llvm::RegisterBank &RB) {
  // Check that the PartialMapping at the given index matches the expected
  // values
  const PartialMapping &Map = PartMappings[Idx - PartialMappingIdx::PMI_Min];
  return Map.StartIdx == ValStartIdx && Map.Length == ValLength &&
         Map.RegBank == &RB;
}

bool TriCoreGenRegisterBankInfo::checkValueMapImpl(unsigned Idx,
                                                   unsigned FirstInBank,
                                                   unsigned Size,
                                                   unsigned Offset) {
  // Check that the ValueMapping at the given index matches the expected values
  unsigned PartialMapBaseIdx = Idx - PartialMappingIdx::PMI_Min;
  const ValueMapping &Map = TriCoreGenRegisterBankInfo::getValueMapping(
      (PartialMappingIdx)FirstInBank, Size)[Offset];
  return Map.BreakDown == &PartMappings[PartialMapBaseIdx] &&
         Map.NumBreakDowns == 1;
}

bool TriCoreGenRegisterBankInfo::checkCarryMapImpl(unsigned Idx,
                                                   unsigned Offset) {
  // Check that the ValueMapping at the given index matches the expected values
  const unsigned PartialMapBaseIdx = Idx - PartialMappingIdx::PMI_Min;
  const ValueMapping &Map =
      TriCoreGenRegisterBankInfo::getCarryMapping()[Offset];
  return Map.BreakDown == &PartMappings[PartialMapBaseIdx] &&
         Map.NumBreakDowns == 1;
}

bool TriCoreGenRegisterBankInfo::checkPartialMappingIdx(
    PartialMappingIdx FirstAlias, PartialMappingIdx LastAlias,
    ArrayRef<PartialMappingIdx> Order) {
  // Check that the PartialMappingIndices matches the expected order.
  if (Order.front() != FirstAlias)
    return false;
  if (Order.back() != LastAlias)
    return false;
  if (Order.front() > Order.back())
    return false;

  PartialMappingIdx Previous = Order.front();
  bool First = true;
  for (const auto &Current : Order) {
    if (First) {
      First = false;
      continue;
    }
    if (Previous + 1 != Current)
      return false;
    Previous = Current;
  }

  return true;
}

unsigned TriCoreGenRegisterBankInfo::getRegBankBaseIdxOffset(unsigned RBIdx,
                                                             unsigned Size) {
  // returned offset is relative to the register bank index
  switch (RBIdx) {
  default:
    return -1;
  case PMI_FirstDataReg:
  case PMI_FirstAddrReg:
    if (Size <= 32)
      return 0;
    else if (Size <= 64)
      return 1;
    else
      return -1;
  case PMI_FirstCarryReg:
    return Size <= 1 ? 0 : -1;
  }
}

const RegisterBankInfo::ValueMapping *
TriCoreGenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx,
                                            unsigned Size) {
  assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");

  // get the relative offset for the value map and check if it is a valid index
  unsigned BaseIdxOffset = getRegBankBaseIdxOffset(RBIdx, Size);
  if (BaseIdxOffset == -1u)
    return &ValMappings[InvalidIdx];

  // calculate the actual index for the value map
  unsigned ValMappingIdx =
      First3OpsIdx + (RBIdx - PartialMappingIdx::PMI_Min + BaseIdxOffset) *
                         ValueMappingIdx::DistanceBetweenRegBanks;

  assert(ValMappingIdx >= First3OpsIdx && ValMappingIdx <= Last3OpsIdx &&
         "Mapping out of bounds");

  return &ValMappings[ValMappingIdx];
}

TriCoreGenRegisterBankInfo::PartialMappingIdx
    TriCoreGenRegisterBankInfo::BankIDToCopyMapIdx[]{
        // order corresponds to the register bank ID enum
        PMI_FirstAddrReg, // AddrReg
        PMI_FirstDataReg, // DataReg
        PMI_None,         // StatusReg
    };

const RegisterBankInfo::ValueMapping *
TriCoreGenRegisterBankInfo::getCopyMapping(unsigned DstBankID,
                                           unsigned SrcBankID, unsigned Size) {
  assert(DstBankID < TriCore::NumRegisterBanks && "Invalid bank ID");
  assert(SrcBankID < TriCore::NumRegisterBanks && "Invalid bank ID");

  PartialMappingIdx DstRBIdx = BankIDToCopyMapIdx[DstBankID];
  PartialMappingIdx SrcRBIdx = BankIDToCopyMapIdx[SrcBankID];

  // if both destination and source regbank are the same return the value
  // mapping for it
  if (DstRBIdx == SrcRBIdx)
    return getValueMapping(DstRBIdx, Size);

  // TODO: add support for cross register bank copies
  llvm_unreachable("Cannot handle cross register bank copies yet.");
}

const RegisterBankInfo::ValueMapping *
TriCoreGenRegisterBankInfo::getTruncMapping(unsigned BankID, unsigned DstSize,
                                            unsigned SrcSize) {
  assert(
      (BankID == TriCore::AddrRegBankID || BankID == TriCore::DataRegBankID) &&
      "Unknown register bank ID");

  // Truncations are only allowed to occur on the same register bank.

  bool DstIs32 = DstSize <= 32;
  bool DstIs64 = !DstIs32 && DstSize <= 64;

  bool SrcIs32 = SrcSize <= 32;
  bool SrcIs64 = !SrcIs32 && SrcSize <= 64;

  // If the sizes are similar truncation is the same as a simple COPY
  if ((DstIs32 && SrcIs32) || (DstIs64 && SrcIs64))
    return getCopyMapping(BankID, BankID, SrcSize);

  assert(DstIs32 && SrcIs64 && "No such mapping!");

  // Otherwise we need a proper truncation mapping
  unsigned TruncIdx = BankID == TriCore::AddrRegBankID ? TruncAddrRegBankIdx
                                                       : TruncDataRegBankIdx;

  return &ValMappings[TruncIdx];
}

const RegisterBankInfo::ValueMapping *
TriCoreGenRegisterBankInfo::getCarryMapping() {
  // XXX: If TriCore ever support add/sub /w carry on address regs or 64-bit
  //  this function needs parameters and some more logic
  return &ValMappings[CarryBitIdx];
}
} // namespace llvm
