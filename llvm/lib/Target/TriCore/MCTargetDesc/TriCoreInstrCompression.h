//===-- TriCoreInstrCompression.h -------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
/// \file
/// This file describes how to compress and uncompress instructions which
/// cannot be generated by the compression backend.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_TARGET_TRICORE_TRICOREINSTRCOMPRESSION_H
#define LLVM_LIB_TARGET_TRICORE_TRICOREINSTRCOMPRESSION_H

#include "MCTargetDesc/TriCoreMCTargetDesc.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCRegisterInfo.h"
#include "llvm/MC/MCSubtargetInfo.h"

namespace llvm {

#ifdef GEN_COMPRESS_INSTR

static bool compress_LDA_aac_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                 const MCInst &MI, const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  const bool IsImmEqualFour =
      (MI.getOperand(3).isImm()) && (MI.getOperand(3).getImm() == 4);

  if (IsOp0AddrReg && IsOp1AddrReg && IsImmEqualFour) {
    // ld.a	$d, [${s2}+]
    OutInst.setOpcode(TriCore::LDA_16_aa_poi);
    // Operand: d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_LDBU_dac_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                  const MCInst &MI,
                                  const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  const bool IsImmEqualOne =
      (MI.getOperand(3).isImm()) && (MI.getOperand(3).getImm() == 1);

  if (IsImmEqualOne && IsOp0DataReg && IsOp1AddrReg) {
    // ld.bu	$d, [${s2}+]
    OutInst.setOpcode(TriCore::LDBU_16_da_poi);
    // Operand: d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_LDH_dac_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                 const MCInst &MI, const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  const bool IsImmEqualTwo =
      (MI.getOperand(3).isImm()) && (MI.getOperand(3).getImm() == 2);

  if (IsImmEqualTwo && IsOp0DataReg && IsOp1AddrReg) {
    // ld.h	$d, [${s2}+]
    OutInst.setOpcode(TriCore::LDH_16_da_poi);
    // Operand: d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_LDW_dac_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                 const MCInst &MI, const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  const bool IsImmEqualFour =
      (MI.getOperand(3).isImm()) && (MI.getOperand(3).getImm() == 4);

  if (IsImmEqualFour && IsOp0DataReg && IsOp1AddrReg) {
    // ld.h	$d, [${s2}+]
    OutInst.setOpcode(TriCore::LDW_16_da_poi);
    // Operand: d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_STA_aca_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                 const MCInst &MI, const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp3AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(3).getReg());

  const bool IsImmEqualFour =
      (MI.getOperand(2).isImm()) && (MI.getOperand(2).getImm() == 4);

  if (IsImmEqualFour && IsOp0AddrReg && IsOp3AddrReg) {
    // st.a	[${s2}+], $s1
    OutInst.setOpcode(TriCore::STA_16_aa_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s1
    OutInst.addOperand(MI.getOperand(3));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_STB_acd_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                 const MCInst &MI, const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp3DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(3).getReg());

  const bool IsImmEqualOne =
      (MI.getOperand(2).isImm()) && (MI.getOperand(2).getImm() == 1);

  if (IsImmEqualOne && IsOp0AddrReg && IsOp3DataReg) {
    // st.b	[${s2}+], $s1
    OutInst.setOpcode(TriCore::STB_16_ad_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s1
    OutInst.addOperand(MI.getOperand(3));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_STH_acd_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                 const MCInst &MI, const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp3DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(3).getReg());

  const bool IsImmEqualTwo =
      (MI.getOperand(2).isImm()) && (MI.getOperand(2).getImm() == 2);

  if (IsImmEqualTwo && IsOp0AddrReg && IsOp3DataReg) {
    // st.h	[${s2}+], $s1
    OutInst.setOpcode(TriCore::STH_16_ad_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s1
    OutInst.addOperand(MI.getOperand(3));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_STW_acd_poi(const MCRegisterInfo &MRI, MCInst &OutInst,
                                 const MCInst &MI, const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp3DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(3).getReg());

  const bool IsImmEqualFour =
      (MI.getOperand(2).isImm()) && (MI.getOperand(2).getImm() == 4);

  if (IsImmEqualFour && IsOp0AddrReg && IsOp3DataReg) {
    // st.w	[${s2}+], $s1
    OutInst.setOpcode(TriCore::STW_16_ad_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s1
    OutInst.addOperand(MI.getOperand(3));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_LEA_aac(const MCRegisterInfo &MRI, MCInst &OutInst,
                             const MCInst &MI, const MCSubtargetInfo &STI) {
  const bool IsOp0SPReg = MRI.getRegClass(TriCore::ImplStackPtrRegRegClassID)
                              .contains(MI.getOperand(0).getReg());

  const bool IsOp1SPReg = MRI.getRegClass(TriCore::ImplStackPtrRegRegClassID)
                              .contains(MI.getOperand(1).getReg());

  const bool IsImmAndValid =
      (MI.getOperand(2).isImm()) &&
      (MI.getOperand(2).getImm() < 0 && MI.getOperand(2).getImm() > -256);

  if (IsImmAndValid && IsOp0SPReg && IsOp1SPReg) {
    // sub.a $a10, $const8
    OutInst.setOpcode(TriCore::SUBA_16_a10c);
    // Operand: a10
    OutInst.addOperand(MI.getOperand(0));
    // Operand: src
    OutInst.addOperand(MI.getOperand(0));
    // Operand: const8
    OutInst.addOperand(MCOperand::createImm(-1 * MI.getOperand(2).getImm()));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_SEL_dddd(const MCRegisterInfo &MRI, MCInst &OutInst,
                              const MCInst &MI, const MCSubtargetInfo &STI) {
  const bool IsOp1D15Reg = MRI.getRegClass(TriCore::ImplDataRegRegClassID)
                               .contains(MI.getOperand(1).getReg());

  const bool IsOp2DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  const bool IsOp3DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(3).getReg());

  const bool IsOp0SameAsOp3 =
      (MI.getOperand(0).getReg() == MI.getOperand(3).getReg());

  if (IsOp1D15Reg && IsOp2DataReg && IsOp3DataReg && IsOp0SameAsOp3) {
    // cmov	$s1_d, $d15, $s2
    OutInst.setOpcode(TriCore::CMOV_16_dd15d);
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: d15
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(2));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_SELN_dddd(const MCRegisterInfo &MRI, MCInst &OutInst,
                               const MCInst &MI, const MCSubtargetInfo &STI) {
  const bool IsOp1D15Reg = MRI.getRegClass(TriCore::ImplDataRegRegClassID)
                               .contains(MI.getOperand(1).getReg());

  const bool IsOp2DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  const bool IsOp3DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(3).getReg());

  const bool IsOp0SameAsOp3 =
      (MI.getOperand(0).getReg() == MI.getOperand(3).getReg());

  if (IsOp1D15Reg && IsOp2DataReg && IsOp3DataReg && IsOp0SameAsOp3) {
    // cmovn	$s1_d, $d15, $s2
    OutInst.setOpcode(TriCore::CMOVN_16_dd15d);
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: d15
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(2));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool compress_LOOP_ac(const MCRegisterInfo &MRI, MCInst &OutInst,
                               const MCInst &MI, const MCSubtargetInfo &STI) {
  const bool IsImmAndValid =
      (MI.getOperand(2).isImm()) &&
      (MI.getOperand(2).getImm() <= -2 && MI.getOperand(2).getImm() >= -32);

  const bool IsOp0SameAsOp1 =
      (MI.getOperand(0).getReg() == MI.getOperand(1).getReg());

  if (IsImmAndValid && IsOp0SameAsOp1) {
    OutInst = MI;
    OutInst.setOpcode(TriCore::LOOP_16_ac);
    return true;
  }
  return false;
}

static bool compressCustomInst(MCInst &OutInst, const MCInst &MI,
                               const MCSubtargetInfo &STI, MCContext &Context) {
  const MCRegisterInfo &MRI = *Context.getRegisterInfo();

  switch (MI.getOpcode()) {
  default:
    return false;
  case TriCore::LDA_aac_poi:
    return compress_LDA_aac_poi(MRI, OutInst, MI, STI);
  case TriCore::LDBU_dac_poi:
    return compress_LDBU_dac_poi(MRI, OutInst, MI, STI);
  case TriCore::LDH_dac_poi:
    return compress_LDH_dac_poi(MRI, OutInst, MI, STI);
  case TriCore::LDW_dac_poi:
    return compress_LDW_dac_poi(MRI, OutInst, MI, STI);
  case TriCore::STA_aca_poi:
    return compress_STA_aca_poi(MRI, OutInst, MI, STI);
  case TriCore::STB_acd_poi:
    return compress_STB_acd_poi(MRI, OutInst, MI, STI);
  case TriCore::STH_acd_poi:
    return compress_STH_acd_poi(MRI, OutInst, MI, STI);
  case TriCore::STW_acd_poi:
    return compress_STW_acd_poi(MRI, OutInst, MI, STI);
  case TriCore::LEA_aac:
    return compress_LEA_aac(MRI, OutInst, MI, STI);
  case TriCore::SEL_dddd:
    return compress_SEL_dddd(MRI, OutInst, MI, STI);
  case TriCore::SELN_dddd:
    return compress_SELN_dddd(MRI, OutInst, MI, STI);
  case TriCore::LOOP_ac:
    return compress_LOOP_ac(MRI, OutInst, MI, STI);
  }
}

#include "TriCoreGenCompressInstEmitter.inc"

static bool compressInstruction(MCInst &OutInst, const MCInst &MI,
                                const MCSubtargetInfo &STI,
                                MCContext &Context) {
  bool Compressed = false;

  if (!STI.getFeatureBits()[TriCore::Allow16BitInstructions])
    return false;

  Compressed = compressInst(OutInst, MI, STI, Context);
  if (!Compressed)
    Compressed = compressCustomInst(OutInst, MI, STI, Context);

  return Compressed;
}

#undef GEN_COMPRESS_INSTR

#elif defined(GEN_UNCOMPRESS_INSTR)

static bool uncompress_LDA_16_aa_poi(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  if (IsOp0AddrReg && IsOp1AddrReg) {
    // ld.a $s1_d, [${s2}+], $off10
    OutInst.setOpcode(TriCore::LDA_aac_poi);
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(4));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_LDBU_16_da_poi(MCInst &OutInst, const MCInst &MI,
                                      const MCRegisterInfo &MRI,
                                      const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  if (IsOp0DataReg && IsOp1AddrReg) {
    // ld.bu $s1_d, [${s2}+], $off10
    OutInst.setOpcode(TriCore::LDBU_dac_poi);
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(1));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_LDH_16_da_poi(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  if (IsOp0DataReg && IsOp1AddrReg) {
    // ld.h $s1_d, [${s2}+], $off10
    OutInst.setOpcode(TriCore::LDH_dac_poi);
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(2));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_LDW_16_da_poi(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  assert(MI.getOperand(1).getReg() == MI.getOperand(2).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(1).getReg());

  if (IsOp0DataReg && IsOp1AddrReg) {
    // ld.w $s1_d, [${s2}+], $off10
    OutInst.setOpcode(TriCore::LDW_dac_poi);
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: dest
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(1));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(4));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_STA_16_aa_poi(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp2AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  if (IsOp0AddrReg && IsOp2AddrReg) {
    // st.a	[${s2}+], $off10, $s1_d
    OutInst.setOpcode(TriCore::STA_aca_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(4));
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(2));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_STB_16_ad_poi(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp2DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  if (IsOp0AddrReg && IsOp2DataReg) {
    // st.b	[${s2}+], $off10, $s1_d
    OutInst.setOpcode(TriCore::STB_acd_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(1));
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(2));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_STH_16_ad_poi(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp2DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  if (IsOp0AddrReg && IsOp2DataReg) {
    // st.h	[${s2}+], $off10, $s1_d
    OutInst.setOpcode(TriCore::STH_acd_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(2));
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(2));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_STW_16_ad_poi(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  assert(MI.getOperand(0).getReg() == MI.getOperand(1).getReg() &&
         "Tied operand mismatch");

  const bool IsOp0AddrReg = MRI.getRegClass(TriCore::AddrRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp2DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  if (IsOp0AddrReg && IsOp2DataReg) {
    // st.w	[${s2}+], $off10, $s1_d
    OutInst.setOpcode(TriCore::STW_acd_poi);
    // Operand: dest
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: off10
    OutInst.addOperand(MCOperand::createImm(4));
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(2));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_SUBA_16_a10c(MCInst &OutInst, const MCInst &MI,
                                    const MCRegisterInfo &MRI,
                                    const MCSubtargetInfo &STI) {
  const bool IsOp0SPReg = MRI.getRegClass(TriCore::ImplStackPtrRegRegClassID)
                              .contains(MI.getOperand(0).getReg());

  const bool IsOp1SPReg = MRI.getRegClass(TriCore::ImplStackPtrRegRegClassID)
                              .contains(MI.getOperand(1).getReg());

  if (IsOp0SPReg && IsOp1SPReg) {
    // lea	$s1_d, [$s2], $off16
    OutInst.setOpcode(TriCore::LEA_aac);
    // Operand: s1_d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    // Operand: off16
    OutInst.addOperand(MCOperand::createImm(-1 * MI.getOperand(2).getImm()));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_CMOV_16_dd15d(MCInst &OutInst, const MCInst &MI,
                                     const MCRegisterInfo &MRI,
                                     const MCSubtargetInfo &STI) {
  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1D15Reg = MRI.getRegClass(TriCore::ImplDataRegRegClassID)
                               .contains(MI.getOperand(1).getReg());

  const bool IsOp2DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  if (IsOp0DataReg && IsOp1D15Reg && IsOp2DataReg) {
    // sel	$d, $s3, $s1, $s2
    OutInst.setOpcode(TriCore::SEL_dddd);
    // Operand: d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s3
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s1
    OutInst.addOperand(MI.getOperand(2));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_CMOVN_16_dd15d(MCInst &OutInst, const MCInst &MI,
                                      const MCRegisterInfo &MRI,
                                      const MCSubtargetInfo &STI) {
  const bool IsOp0DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(0).getReg());

  const bool IsOp1D15Reg = MRI.getRegClass(TriCore::ImplDataRegRegClassID)
                               .contains(MI.getOperand(1).getReg());

  const bool IsOp2DataReg = MRI.getRegClass(TriCore::DataRegsRegClassID)
                                .contains(MI.getOperand(2).getReg());

  if (IsOp0DataReg && IsOp1D15Reg && IsOp2DataReg) {
    // seln	$d, $s3, $s1, $s2
    OutInst.setOpcode(TriCore::SELN_dddd);
    // Operand: d
    OutInst.addOperand(MI.getOperand(0));
    // Operand: s3
    OutInst.addOperand(MI.getOperand(1));
    // Operand: s1
    OutInst.addOperand(MI.getOperand(2));
    // Operand: s2
    OutInst.addOperand(MI.getOperand(0));
    OutInst.setLoc(MI.getLoc());
    return true;
  }
  return false;
}

static bool uncompress_LOOP_16_ac(MCInst &OutInst, const MCInst &MI,
                                    const MCRegisterInfo &MRI,
                                    const MCSubtargetInfo &STI) {
  const bool IsOp0SameAsOp1 =
      (MI.getOperand(0).getReg() == MI.getOperand(1).getReg());

  if (IsOp0SameAsOp1) {
    OutInst = MI;
    OutInst.setOpcode(TriCore::LOOP_ac);
    return true;
  }
  return false;
}

static bool uncompressCustomInst(MCInst &OutInst, const MCInst &MI,
                                 const MCRegisterInfo &MRI,
                                 const MCSubtargetInfo &STI) {
  switch (MI.getOpcode()) {
  default:
    return false;
  case TriCore::LDA_16_aa_poi:
    return uncompress_LDA_16_aa_poi(OutInst, MI, MRI, STI);
  case TriCore::LDBU_16_da_poi:
    return uncompress_LDBU_16_da_poi(OutInst, MI, MRI, STI);
  case TriCore::LDH_16_da_poi:
    return uncompress_LDH_16_da_poi(OutInst, MI, MRI, STI);
  case TriCore::LDW_16_da_poi:
    return uncompress_LDW_16_da_poi(OutInst, MI, MRI, STI);
  case TriCore::STA_16_aa_poi:
    return uncompress_STA_16_aa_poi(OutInst, MI, MRI, STI);
  case TriCore::STB_16_ad_poi:
    return uncompress_STB_16_ad_poi(OutInst, MI, MRI, STI);
  case TriCore::STH_16_ad_poi:
    return uncompress_STH_16_ad_poi(OutInst, MI, MRI, STI);
  case TriCore::STW_16_ad_poi:
    return uncompress_STW_16_ad_poi(OutInst, MI, MRI, STI);
  case TriCore::SUBA_16_a10c:
    return uncompress_SUBA_16_a10c(OutInst, MI, MRI, STI);
  case TriCore::CMOV_16_dd15d:
    return uncompress_CMOV_16_dd15d(OutInst, MI, MRI, STI);
  case TriCore::CMOVN_16_dd15d:
    return uncompress_CMOVN_16_dd15d(OutInst, MI, MRI, STI);
  case TriCore::LOOP_16_ac:
    return uncompress_LOOP_16_ac(OutInst, MI, MRI, STI);
  }
}

#include "TriCoreGenCompressInstEmitter.inc"

static bool uncompressInstruction(MCInst& OutInst,
                           const MCInst &MI,
                           const MCRegisterInfo &MRI,
                           const MCSubtargetInfo &STI) {
  bool Uncompressed = false;

  if (!STI.getFeatureBits()[TriCore::Allow16BitInstructions])
    return false;

  Uncompressed = uncompressInst(OutInst, MI, MRI, STI);
  if (!Uncompressed)
    Uncompressed = uncompressCustomInst(OutInst, MI, MRI, STI);

  return Uncompressed;
}

#undef GEN_UNCOMPRESS_INSTR

#else
#error Need to define GEN_COMPRESS_INSTR OR GEN_UNCOMPRESS_INSTR
#endif

} // namespace llvm

#endif // LLVM_LIB_TARGET_TRICORE_TRICOREINSTRCOMPRESSION_H
